# Quantum Shuttle

## Challenge information:
   In Quαntum Snαcks we discussed qubits αnd single qbit gαtes. In this exercise we will move on to multible qubits.
   For this question we will look at a the controlled NOT-gate. 
   In the classical controlled-NOT two bits are input and the output can be described as follows: 
   the first bit (control bit) does not change, the second bit (target bit) flips (NOT-gate) if the control bit is 1.
   Example:CNOT(10), the control bit is 1, the target bit is 0. So the output would be: CNOT(10) = 11, since the control bit does not change but the target 
   bit flips (since the control bit is 1).
   We can also consider the controlled-not operator where the first bit is the target bit and
   the second bit is the control bit. We denote this with NOTC. So for example NOTC(11) = 01.


### Flag 1 [50 points]
####     Bitstring

####     Desription:
   Consider the following bit-string b = 000101001011, and denote b[i] to be the i-th digit of b
   What is the resulting bit-string generated by the following protocol
   CNOT(b[1]b[2])NOTC(b[3]b[4])CNOT(b[7]b[5])NOTC(b[6]b[8])CNOT(b[11]b[12])NOTC(b[10]b[9])
   Note: you do not need to use the verification tool for this subtask. You can enter the bitstring directly as the flag.
        
####     Solution:
   I used python for this one.
   First we need to make CNOT and NOCT functions. Then we need to make that protocol line an actual python code. 
   I make it fstrings so I can easely concat and  print result.
   Also I added 1 zero to begining of bit string because I am lazy to change all of indexes :D
        ```
        def CNOT(a, b):
            if a == '1':
                return f"1{int(not int(b))}"
            else: return f"{a}{b}"

        def NOTC(a, b):
            if b == '1':
                return f"{int(not int(a))}1"
            else: return f"{a}{b}"


        b = '0000101001011'
        res = f"{CNOT(b[1], b[2])}" + f"{NOTC(b[3], b[4])}" + f"{CNOT(b[7], b[5])}" + f"{NOTC(b[6], b[8])}" + f"{CNOT(b[11], b[12])}" + f"{NOTC(b[10], b[9])}"

        print(res)
        

   **FLAG: 001100101011**

### Flag 2 [50 points]:
####     CNOT

####     Desription:
   Before you continue, have a look at the background in the PDF attached to this challenge.
   In the classical situation the CNOT gate always keeps the control bit the same but changes the target bit.
   Refer to the previous Quantum Snacks exercise (subtask 1) where we had a number different qubit states. 
   For this exercise, we restrict ourselves to the states that you identified for that subtask.
   Can you come up with a combination (pair) of qubit states which leave the target bit the same but changed the control bit?
   Write your answer (using the verification tool) as a list of numbers that correspond to the below equation: [A,B,C,D,E,F]. 
   
   ![CodeCogsEqn2](https://user-images.githubusercontent.com/17177071/127026311-ac653c48-5a25-4986-b2de-cc23c1649fec.png)


####     Solution:
   All posible values for qbits are (0, 1, -1, 1/sqrt(2), -1/sqrt(2)).
   We can say that A and D is defenetly 2. As 1/sqrt(2) is outside of brackets we can say that B,C,E and F is 0, 1 or -1. 
   I am lazy to do math so I bruteforced solution tester. We can give him numbers with get request:

        ```
        import requests as r
        import itertools

        url = 'https://0ea4d44af418f983943bf03c3f10f998.challenge.hackazon.org/'
        postfix = '&submit=Verify'

        for i in itertools.product([0,1,-1],repeat=4):
            data = url + f"[2,{i[0]},{i[1]},2,{i[2]},{i[3]}]" + postfix
            res = r.get(data)
            print(i)
            if 'wrong' not in res.text:
                    print(res.text)
                    break

   
   Write sequense: [2, 1, 1, 2, 1, -1]
   **FLAG: CTF{quantum_is_cnot_co_bad}**

###     Flag 2 [50 points]:
####     Strange thing

####     Desription:
   We see some interesting behaviour related to the CNOT gate in the quantum case, it is possible to leave the target qubit the same but change the control qubit!
   There is something even stranger happening, sometimes it is possible to transform a state in such a way that we can no longer write it as a tensor product 
   of two individual states (the qubit states become entangled). In general we can write a tensor product as follows,
   
   ![CodeCogsEqn](https://user-images.githubusercontent.com/17177071/127026114-92ddc256-935f-4b1e-9901-a8fcc86e1508.png)
   
   Can you think of a two-qubit state (represented as a 4-dimensional vector, the right hand side of the above equation) that can not be written as the 
   tensor product of two individual qubit states? Write your answer (using the verification tool) as a list of numbers that correspond to the below 
   equation: [A,B,C,D,E].
   
   ![CodeCogsEqn3](https://user-images.githubusercontent.com/17177071/127026335-c73a2fea-4d45-41b8-b5ac-537005deef44.png)


####     Solution:
   Same as above, except there is only one '2'.
        ```
        import requests as r
        import itertools

        url = 'https://0ea4d44af418f983943bf03c3f10f998.challenge.hackazon.org/'
        postfix = '&submit=Verify'

        for i in itertools.product([0,1,-1],repeat=4):
            data = url + f"[2,{i[0]},{i[1]},{i[2]},{i[3]}]" + postfix
            res = r.get(data)
            print(i)
            if 'wrong' not in res.text:
                    print(res.text)
                    break


   Right sequense: [2, 0, 1, 1, 0]
   
   **FLAG: CTF{quantum_shooting_for_the_stars}**
